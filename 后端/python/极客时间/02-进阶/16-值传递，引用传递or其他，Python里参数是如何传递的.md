引用 传递

- 所谓引用传递，通常是指把参数的引用传给新的变量，这样，原变量和新变量就会指向同一块内存地址。如果改变了其中任何一个变量的值，那么另外一个变量也会相应地随之改变。

```python
a = 1

b = a
#b=1
a = a + 1
#a=2
```

Python 的数据类型，例如整型（int）、字符串（string）等等，是不可变的。所以，a = a + 1，并不是让 a 的值增加 1，而是表示重新创建了一个新的值为 2 的对象，并让 a 指向它。但是 b 仍然不变，仍然指向 1 这个对象。  
简单的赋值 b = a，并不表示重新创建了新对象，只是让同一个对象被多个变量指向或引用。

对于列表

```python
l1 = [1, 2, 3]

l2 = l1

l1.append(4)

l1

[1, 2, 3, 4]

l2

[1, 2, 3, 4]
```

总结：

- 变量的赋值，只是表示让变量指向了某个对象，并不表示拷贝对象给变量；而一个对象，可以被多个变量所指向。
- 可变对象（列表，字典，集合等等）的改变，会影响所有指向该对象的变量。
- 对于不可变对象（字符串，整型，元祖等等），所有指向该对象的变量的值总是一样的，也不会改变。但是通过某些操作（+= 等等）更新不可变对象的值时，会返回一个新的对象。
  变量可以被删除，但是对象无法被删除。

## python 函数的参数传递

官方 api 的解释：

> 准确地说，Python 的参数传递是`赋值传递 （pass by assignment）`，或者叫作对象的引用传递（pass by object reference）。Python 里所有的数据类型都是对象，所以参数传递时，只是让新变量与原变量指向相同的对象而已，并不存在值传递或是引用传递一说。
> eg

```python
def my_func1(b):

	b = 2



a = 1

my_func1(a)

a

1
```

当可变对象当作参数传入函数里的时候，改变可变对象的值，就会影响所有指向它的变量。  
eg3:

```python
def my_func3(l2):

	l2.append(4)



l1 = [1, 2, 3]

my_func3(l1)

l1

[1, 2, 3, 4]
```

注意与下面的区分：  
eg4:

```python
def my_func4(l2):

	l2 = l2 + [4]



l1 = [1, 2, 3]

my_func4(l1)

l1

[1, 2, 3]
```

> 这里 l2 = l2 + [4]，表示创建了一个“末尾加入元素 4“的新列表，并让 l2 指向这个新的对象。这个过程与 l1 无关，因此 l1 的值不变。

注意上面 eg3 与 eg4 的区别：

- my_func3() 中单纯地改变了对象的值，因此函数返回后，所有指向该对象的变量都会被改变；
- 但 my_func4() 中则创建了新的对象，并赋值给一个本地变量，因此原变量仍然不变。

## 总结

和其他语言不同的是，Python 中参数的传递既不是值传递，也不是引用传递，而是赋值传递，或者是叫对象的引用传递。  
需要注意的是，这里的赋值或对象的引用传递，不是指向一个具体的内存地址，而是指向一个具体的对象。

- 如果对象是可变的，当其改变时，所有指向这个对象的变量都会改变。
- 如果对象不可变，简单的赋值只能改变其中一个变量的值，其余变量则不受影响。

清楚了这一点，如果你想通过一个函数来改变某个变量的值，通常有两种方法。一种是直接将可变数据类型（比如列表，字典，集合）当作参数传入，直接在其上修改；第二种则是创建一个新变量，来保存修改后的值，然后将其返回给原变量。在实际工作中，我们更倾向于使用后者，因为其表达清晰明了，不易出错。
